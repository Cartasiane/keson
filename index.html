<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>K</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="color-scheme" content="dark">
  <meta name="supported-color-schemes" content="dark light">

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.179.1/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.179.1/examples/jsm/"
    }
  }
  </script>

  <style>
    html, body { margin: 0; height: 100%; background: #000; }
    @supports (padding: max(0px)) {
      body {
        padding:
          env(safe-area-inset-top)
          env(safe-area-inset-right)
          env(safe-area-inset-bottom)
          env(safe-area-inset-left);
      }
    }
    canvas { display: block; position: fixed; inset: 0; }

    /* Calendar button styles */
    .calendar-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(255,255,255,0.9);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      cursor: pointer;
      transition: background 0.2s ease;
      z-index: 10;
    }
    .calendar-btn:hover { background: white; }
    .calendar-btn svg { width: 24px; height: 24px; fill: #000; }
  </style>
</head>
<body>
<!-- Calendar button -->
<a href="https://keson.acab.love/cal.html" target="_blank" class="calendar-btn" title="Open Calendar" rel="noopener noreferrer">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M19 4h-1V2h-2v2H8V2H6v2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11zm0-13H5V6h14v1z"/>
  </svg>
</a>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

// ===== scene =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0a0a);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
camera.up.set(0, 1, 0);

const isMobile = /Mobi|Android/i.test(navigator.userAgent) || window.matchMedia('(max-width: 768px)').matches;
const renderer = new THREE.WebGLRenderer({
  antialias: true,
  powerPreference: 'low-power',
  logarithmicDepthBuffer: true
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.2 : 1.5));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1;
document.body.appendChild(renderer.domElement);

// ===== lights =====
scene.add(new THREE.AmbientLight(0xffffff, 0.55));
const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 0.9); scene.add(hemi);
const key  = new THREE.DirectionalLight(0xffffff, 1.2); key.position.set(8, 14, 10); scene.add(key);
const rim  = new THREE.DirectionalLight(0xffffff, 0.9); rim.position.set(-10, 6, -8); scene.add(rim);

// ===== group =====
const group = new THREE.Group();
scene.add(group);

// ===== material helpers =====
const mat = (opts) => Object.assign(new THREE.MeshStandardMaterial(opts), { side: THREE.DoubleSide });
const matDarkGreyMetal = mat({ color: 0x444444, metalness: 0.8,  roughness: 0.3 });
const matBlackMetal    = mat({ color: 0x000000, metalness: 0.85, roughness: 0.25 });
const matBlackPlastic  = mat({ color: 0x111111, metalness: 0.0,  roughness: 0.6 });

// ===== painted-wood procedural maps (no external files) =====
function createNoiseTexture(size = 256, contrast = 0.85) {
  const c = document.createElement('canvas'); c.width = c.height = size;
  const ctx = c.getContext('2d', { willReadFrequently: true });
  const img = ctx.createImageData(size, size);
  for (let i = 0; i < img.data.length; i += 4) {
    const v = Math.random() * 255;
    img.data[i] = img.data[i+1] = img.data[i+2] = v; img.data[i+3] = 255;
  }
  ctx.putImageData(img, 0, 0);
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.anisotropy = 8; tex.generateMipmaps = true; tex.needsUpdate = true;
  return tex;
}

function createBrushHeightTexture(size = 512, strokeDir = 0) {
  const c = document.createElement('canvas'); c.width = c.height = size;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#808080'; ctx.fillRect(0, 0, size, size);
  const strokes = Math.floor(size * 0.12);
  for (let s = 0; s < strokes; s++) {
    const x0 = Math.random() * size; const y0 = Math.random() * size;
    const len = size * (0.8 + Math.random() * 0.4);
    const w = 1 + Math.random() * 3; const amp = 2 + Math.random() * 6; const freq = 0.005 + Math.random() * 0.015;
    ctx.save(); ctx.translate(x0, y0); ctx.rotate(strokeDir + (Math.random() * 0.2 - 0.1)); ctx.beginPath();
    for (let t = 0; t < len; t++) { const x = t; const y = Math.sin(t * freq) * amp; t === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y); }
    const shade = 110 + Math.random() * 30; ctx.lineWidth = w; ctx.strokeStyle = `rgb(${shade},${shade},${shade})`; ctx.globalAlpha = 0.5; ctx.stroke(); ctx.restore();
  }
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.anisotropy = 8; tex.generateMipmaps = true; tex.needsUpdate = true; return tex;
}

function createGrainNormalLike(size = 256) {
  const c = document.createElement('canvas'); c.width = c.height = size; const ctx = c.getContext('2d');
  const img = ctx.createImageData(size, size);
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      const v = (Math.sin((x * 0.15) + Math.random() * 0.5) * 0.5 + 0.5) * 255; const i = (y * size + x) * 4;
      img.data[i+0] = v; img.data[i+1] = 128; img.data[i+2] = 255 - v; img.data[i+3] = 255;
    }
  }
  ctx.putImageData(img, 0, 0); const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.anisotropy = 8; tex.generateMipmaps = true; tex.needsUpdate = true; return tex;
}

const paintedNoise = createNoiseTexture(256, 0.85);      // roughnessMap
const brushHeight  = createBrushHeightTexture(512, 0.0);  // bumpMap
const grainNormal  = createGrainNormalLike(256);          // optional normal

function makePaintedWood(color = 0x1e1e1e) {
  const m = new THREE.MeshPhysicalMaterial({
    color,
    metalness: 0.0,
    roughness: 0.68,
    clearcoat: 0.05,
    clearcoatRoughness: 0.4,
    side: THREE.DoubleSide,
  });
  m.roughnessMap = paintedNoise;
  m.bumpMap = brushHeight; m.bumpScale = 0.0025;
  m.normalMap = grainNormal; m.normalScale = new THREE.Vector2(0.15, 0.3);
  const REP = 3.0;
  for (const t of [m.roughnessMap, m.bumpMap, m.normalMap]) { if (!t) continue; t.repeat.set(REP, REP * 1.6); t.needsUpdate = true; }
  return m;
}

function randomizePaintUV(material, strength = 0.25) {
  const tx = material.roughnessMap || material.bumpMap || material.normalMap; if (!tx) return;
  const off = new THREE.Vector2((Math.random() - 0.5) * strength, (Math.random() - 0.5) * strength);
  tx.offset.add(off); tx.rotation = (Math.random() - 0.5) * 0.35; tx.needsUpdate = true;
  if (material.bumpMap && material.bumpMap !== tx) { material.bumpMap.offset.copy(tx.offset); material.bumpMap.rotation = tx.rotation; }
  if (material.normalMap && material.normalMap !== tx) { material.normalMap.offset.copy(tx.offset); material.normalMap.rotation = tx.rotation; }
}

// ===== colors & materials =====
const colors = [0x60b502, 0xf8e503, 0xe081f5, 0xfd3f4b];
const matCycleNAUO5 = new THREE.MeshStandardMaterial({ color: colors[0], metalness: 0.0, roughness: 0.65, side: THREE.DoubleSide });
const matWoodBlack  = makePaintedWood(0x1e1e1e);
const matCycleWOOD  = makePaintedWood(colors[0]);

let meshesNAUO5 = [];
let meshesWood  = [];

// ===== loader =====
const loader = new GLTFLoader();
loader.setMeshoptDecoder(MeshoptDecoder);
const MODEL_URL = './model.glb';

loader.load(MODEL_URL, (gltf) => {
  const obj = gltf.scene;

  obj.traverse((child) => {
    if (child.isMesh) {
      child.frustumCulled = false;
      const pname = child.parent?.name || child.name || '';
      if (pname.includes('NAUO27_(Meshed)')) {
        child.material = matDarkGreyMetal;
      } else if (pname.includes('NAUO30_(Meshed)') || pname.includes('Adam_Hall_34001Schalengriff_(Meshed)')) {
        child.material = matBlackMetal;
      } else if (pname.includes('NAUO28_(Meshed)')) {
        child.material = matBlackPlastic;
      } else if (pname.includes('NAUO5_(Meshed)')) {
        child.material = matCycleNAUO5; meshesNAUO5.push(child);
      } else {
        child.material = matWoodBlack; meshesWood.push(child);
      }
    }
  });

  // Center model
  const box = new THREE.Box3().setFromObject(obj);
  const center = box.getCenter(new THREE.Vector3());
  obj.position.sub(center);
  group.add(obj);

  // Fit camera
  const sphere = new THREE.Sphere(); box.getBoundingSphere(sphere);
  fitCamera(camera, sphere, group.position);

  // Controls
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true; controls.dampingFactor = 0.08;
  controls.rotateSpeed = 0.8; controls.zoomSpeed = 1.0; controls.panSpeed = 0.6;
  controls.enablePan = true; controls.autoRotate = false; controls.target.copy(group.position);

  // Randomize UV transforms a little so parts don't look identical
  meshesWood.forEach((m) => randomizePaintUV(m.material));

  // Phase color loop (unchanged behavior, materials improved)
  let phase = 1; let step = 0; const TICK_MS = 1000; const STEPS_PER_CYCLE = colors.length;
  meshesWood.forEach(m => m.material = matWoodBlack);

  setInterval(() => {
    if (phase === 1) {
      matCycleNAUO5.color.setHex(colors[step % STEPS_PER_CYCLE]);
      step++;
      if (step >= STEPS_PER_CYCLE) {
        phase = 2; step = 0;
        matCycleWOOD.color.copy(matCycleNAUO5.color);
        meshesWood.forEach(m => m.material = matCycleWOOD);
      }
    } else if (phase === 2) {
      const col = colors[step % STEPS_PER_CYCLE];
      matCycleNAUO5.color.setHex(col);
      matCycleWOOD.color.setHex(col);
      step++;
      if (step >= STEPS_PER_CYCLE) {
        phase = 3; step = 0;
        meshesNAUO5.forEach(m => m.material = matWoodBlack); // NAUO5 fades to wood too
        meshesWood.forEach(m  => m.material = matWoodBlack);
      }
    } else if (phase === 3) {
      step++;
      if (step >= STEPS_PER_CYCLE) {
        phase = 1; step = 0;
        matCycleNAUO5.color.setHex(colors[0]);
        meshesNAUO5.forEach(m => m.material = matCycleNAUO5);
        meshesWood.forEach(m  => m.material = matWoodBlack);
      }
    }
  }, TICK_MS);

  // Manual auto-spin on X and Z
  const clock = new THREE.Clock();
  const spinX = 0.08; const spinZ = 0.18;
  function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    group.rotation.x += spinX * dt; group.rotation.z += spinZ * dt;
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

}, (ev) => {
  // optional progress: console.log((ev.loaded/ev.total*100).toFixed(1)+'%');
}, (err) => console.error('GLB load error:', err));

// Fit camera helper
function fitCamera(cam, sphere, lookTarget) {
  const radius = Math.max(1e-6, sphere.radius);
  const margin = isMobile ? 1.4 : 1.28;
  const r = radius * margin;
  const vFOV = THREE.MathUtils.degToRad(cam.fov);
  const hFOV = 2 * Math.atan(Math.tan(vFOV / 2) * cam.aspect);
  const distV = r / Math.sin(vFOV / 2);
  const distH = r / Math.sin(hFOV / 2);
  const dist  = Math.max(distV, distH);
  cam.position.set(0, r * 1.6, dist * 0.9);
  cam.lookAt(lookTarget);
  cam.near = Math.max(0.01, r * 0.02);
  cam.far  = Math.max(cam.near * 50, dist + r * 10, 100);
  cam.updateProjectionMatrix();
}

// Resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
